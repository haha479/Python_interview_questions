Linux
.查看linux的启动时间, 磁盘使用量, 内存使用量
	启动时间 who -b
	磁盘使用量 df -k
	内存使用量 htop

PYTHON内部
.python是强类型还是弱类型语言
	强类型, 我认为, 如果一个语言经常隐式转换变量的类型, 他就是弱类型语言
	, 如果他很少进行隐式转换变量类型, 他就是强类型语言

.怎么说python是动态语言
	因为python是在运行时检查变量的类型, 而静态语言是在编译的时候检查变量的类型
	静态类型需要在定义变量时声明类型

.线程和进程
.. 进程是什么,线程是什么
	进程 : 是具有一定独立功能的程序,它是系统进行资源分配和调度的独立单位
	也就是说,进程是可以可以独立运行的一段程序

	线程 : 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位,
	线程自己基本上不拥有系统资源,但是可以访问属于进程的资源

..进程间通信的方式有几种
	消息队列Queue,管道,信号量,一般是用消息队列Queue

.. 线程和进程的关系,什么时候用线程,什么时候用进程
	线程作为调度和分配的基本单位,进程作为拥有资源的基本单位
	一个程序必须要有一个进程,一个进程至少有一个线程,
	线程间可以共享数据,所以说一些要求同时进行并且又要共享变量的
	并发操作就只能用线程了
	I/O密集运算的,用多线程, 因为I/O密集运算时, 底层是用的C运行的, 这样程序就不会受GIL影响
	CPU密集运算的,用多进程, 在计算时, 多个进程并行会提高效率


..多线程和多进程的区别
	多线程间共享变量,多进程间不能,在python中,实际上多线程是不存在的,因为有了个GIL
	,但是一些I/O密集的操作,多线程还是比多进程要好的
	
	
.. 线程池原理
	如果说线程不能被重用,那就等于说每次创建都要经历创建,运行,和销毁3个过程
	,这样就降低了cpu运行的效率,而线程池就是将线程预先放到线程池中同时处理完
	当前任务之后不是销毁而是执行下一个任务
	一句话,增加了线程的重复调用,减少了创建和销毁,提高了CPU运行效率

.python的GLI全局锁 
	这是python遗留下来的bug
	就是保证任何时候,同时只能有一个线程在运行,
	因为线程间是共享数据的,如果在同一时刻,同时有多个线程修改同一个数据,肯定会乱套
	所以GIL就是为了保持不同线程之间的数据一致性

.python的垃圾回收机制
	引用计数, 标记清除, 分代回收
	引用计数 : 当一个对象被引用时, 它的引用计数就会加一, 为零时, 该对象就被回收了
	标记清除 : 弥补了引用计数的缺陷, 标记清除可以清除掉循环引用的两个或以上的对象
	分代回收 : 分代回收是建立在标记清除的技术基础之上的

.迭代器和生成器
.. 什么是迭代器,生成器
	生成器 : 一边循环一边计算的机制,generator,跟普通的函数不同的是,它是用yield返回一个值,
			 并且挂起函数的状态,然后下次执行的时候就可以从上次离开的地方继续执行

	迭代器 : 实现了__next__方法的对象都可以被称为迭代器
			,它与列表的区别就是,他不会把所有元素加载到内存中,而是调用next方法才返回元素

.. 生成器和迭代器的联系和差别
	生成器和迭代器差不多,是一种特殊的函数

.简述yield的用法
	yield和普通函数内的return相似,但是函数中执行return后会退出该函数,
	而函数中执行到yield的时候会返回指定一个值,并且将该函数挂起,记录下当前执行的状态
	简单点说,yield就是把一个函数变成一个generator
	,调用函数不会执行,而是返回一个生成器genertor对象

.简述装饰器的功能,用法,如何写一个装饰器
	功能 : 在不修改函数内部代码的前提下,给该函数添加功能

	用法 : 封装一个函数,该函数用于装饰其他需要被装饰的函数,该函数就可称为装饰器
	在该函数中传入参数,参数是需要被装饰函数的引用
	在需要被装饰的函数上面写上@装饰器名,

	写一个装饰器 : 定义一个函数,在该函数中内嵌一个函数,并在外部函数中返回该内嵌函数的
	引用,内嵌函数中写一些需要加在被装饰函数中的功能,并且执行被装饰的函数,
	也就是执行外部函数中传的函数
	被装饰的函数如果带参数除了在调用的时候传递实参,在装饰器中也要定义形参接收

[
	{'name':'Andy','age':25},{'name':'Joe','age':40},
	{'name':'Ken','age':16},{'name':'Julia','age':31}
]
将以上列表中的元素按age排序
list.sort()(作用到list列表) 或 sorted(list)(返回一个新列表)

.可变与不可变类型
	对于可变和不可变类型,差别就在于你改变了它的值之后,它的内存地址有没有发生变化

.调试python代码的方式有哪些
	print
	pdb : 启动方式 python -m pdb test.py

.__new__和__init__的区别
	__new__在创建对象时调用,__init__在创建完后调用
	,所以__new__是可以限制对象的创建的,接收的参数是类
	,一般都写cls,并且new方法必须返回一个实例对象,
	如果不返回,init就不会被调用
	init方法接收的self就是由new方法创建出来的实例对象

.你知道的设计模式
	单例模式 : 在创建对象时,保证对象的唯一性
	工厂模式 : 就是定义了一个创建对象的接口,也就是说专门定义一个类来负责创建其他类的实例,
				而所说的其他类就是抽象类衍生出的子类
				所以一般在不知道用户要创建什么样的对象时使用,

.手写一个正则匹配邮箱
	re.match(r'^[\w+]{0,19}@(126|163|qq)\.(com|cn|net)$','123456@126.com')
	如果问大写的QQ怎么办,就说写个compile,不区分大小写

.正则匹配手机号
	r'1[1-9]{10}'

.copy和deepcopy的区别
	copy复制了对象,但对于对象中的元素,还是使用原始的引用
	deepcopy复制了对象,以及对象中的所有元素

.re中match和search方法的不同
	match是从起始位置往后找,serch是从任何位置找

.使用python操作文件
..如何使用python删除一个文件
	os模块中的remove函数

..复制文件
	将被拷贝的文件中的内容写入到需要拷贝的文件在中
	使用read(),write()等方法

.python中的pass语句的作用
	有一些程序思路还没有写好,然后又不能空着不写,所以就用pass来占位

.read,readline和readlines三者的区别
	read是读取整个文件,也可以指定读取的长度字节, read(size)
	readline是读取下一行, 一般在内存较小时使用
	readlines是读取整个文件到一个迭代器以供遍历, 占用内存较多

.python2和python3的主要差异
	python2中默认使用Ascii编码, Python3默认使用unicode编码, 但是程序运行时是使用unicode
	python3中print作为函数存在

.python有哪些数据类型
	string,list,set,dict,int,float,bool

.tuple和list的区别和应用场景
	tuple中的元素不能修改,一开始就定义了长度,对于list来说
	,因为tuple中的元素不能删除和添加,所以比list更安全
	,所以说如果希望定义的数据结构是一旦定义就不能改变的话,就用tuple

	list中的元素可以修改,修改长度时,会影响其他元素的顺序

.用匿名函数写一个功能
	过滤偶数
	lis = [1,2,3,4,5,6]
	filter(lambda x : x % 2 == 1,lis)
	返回 [1,3,5]

.python中的map, reduce, filter函数
	sum : 求一个列表中的和
	map : 接受一个函数和一个可迭代对象为参数, 将该对象中的所有元素执行该函数
	reduce : python2中可直接用, python3中需引用 from functools import reduce
			接受一个函数和一个可迭代对象, 该函数必须接收两个参数
			, 依次从序列中拿出一个参数和上一个参数作为函数的参数
	filter : 过滤用, 接收一个函数和一个可迭代对象, 该函数需返回一个布尔值
			 ,对象中的元素依次执行该函数

.python交互模式中输入u'hello',和print u'hello'为什么不同
	因为print本身也是一个函数,他会自动转义识别u后面的hello为unicode字符串
	,这样python就会将该字符串当作unicode字符串输出

.为什么列表不能作为字典的Key?例 : dict[[1,2,3]] = 4 报错
	list不支持__hash__方法

.列举常用的python标准库
	re,time,random,threading,multiprocessing,hashlib,Queue,urllib,urllib2,
	os,sys,md5,json,socket

.怎么让一个列表逆序
	reverse()(是在原列表上直接进行修改的);切片[::-1](返回一个列表);
	reversed(list)(返回一个迭代器,也可以用list转换)

.取出一个列表中最大的值
	max(list)

.Python输出列表中的值和索引
	使用枚举 : enumerate(list)

.删除重复元素
	集合set(会影响列表里的排列顺序);
	定义一个新列表,将作用列表遍历,将在新列表中没出现过的元素添加到新列表
	使用列表推导式 [lis2.append(j) for j in lis1 if j not in lis2]

.python的pickling模块
	pickle.dump()用于写入文件,pickle.load()用来读取文件内容

.python的json模块的loads和dumps方法
	dumps : 将python对象编码成json字符串
	loads : 将以编码的json字符串解码为python对象

.类方法和静态方法
	类方法 : 有@classmethod装饰的方法,可以被类或类的实例调用,第一个参数必须要传类

	静态方法 : 有@staticmethod装饰的方法,类似函数,可以被类或实例调用
.. 为什么要使用静态方法
	因为有的方法是属于类公用的,而不是属于类的某个实例的

.协程
	协程 : 协程是单线程的,并且在执行中,是人为调用的,比多线程之间调用消耗的资源要少很多

.range和xrange的区别(在python2中)
	range生成一个序列
	xrange生成的是一个xrange对象
	如果说是用于循环的话,xrange会比range快
	,因为用range的话,它会直接将序列里面所有的元素一次性加载出来,
	所以说对于内存来说也是xrange好一点
	,不过在python3中已经移除了range,并且把xrange改成了range

.*args和**kwargs
	当你不确定你要传多少参数时可以使用*args, **args也是一样, 
	这两种既可以在形参中使用, 也可以在实参中使用

.python中单下划线和双下划线的区别
	单下划线一般类的方法或属性, 双下划线表示是该类的私有属性或方法

.列举python中的魔法方法及其用途
	__new__, 创建实例时调用
	__init__, 成功创建实例后调用
	__del__, 实例被删除时调用
	__str__, 打印实例时调用
	__iter__, 用于被迭代时定义的方法


.pep8编码规范
	缩进 : 4个空格的缩进
	函数的左括号前不要加空格
	类中间相隔两个换行
	变量命名 : 避免小写的l,和大写字母O和大写字母I,类名称首字母大写
	避免使用空格的情况 : 在逗号,分号,冒号之前不要加空格,
						 在切片的时候,避免使用空格

.数组,链表,hash表/字典区别,说明各自的应用场景,举例
	数组中的元素是按顺序存放的,并且定义时,需要分配空间,可以通过下标迅速访问元素
	,但是如果插入一个元素,需要移动大量元素
	而链表中的元素不是顺序存储的,不需要定义空间大小是按指针存储的
	,访问的时候先从第一个元素开始,一直找到需要的元素
	,但是增加或者删除就比数组要快很多,只需要修改元素的指针就行了
	所以 : 如果是查询用的多的话,考虑用数组,插入或删除用多就需要用链表了
	hash表(也叫散列表) : 类似字典,比字典慢,找不到返回Null,使用多线程读取
	字典 : 找不到报错,单线程读取,他可以与其他数据类型内嵌使用

.栈和队列的区别
	栈 : 先进后出,栈中的元素空时,再pop会报错
	队列 : 先进先出,队列里的元素空时,再get会一直阻塞

.什么是栈溢出, 什么情况下可能出现
	在python中, 函数是通过栈这种数据结构实现的, 每当进入一个函数调用, 栈就会加一层栈帧
	, 每当函数返回, 栈就会减一层栈帧
	所以说在python中, 递归函数调用的次数过多, 就会造成栈溢出

Web相关AndFramework
.简述HTTP协议的特点,常见的请求头,响应头
..HTTP协议特点
	是基于TCP/IP通信协议来传递数据
	无状态 : 协议对于事务处理没有记忆能力,也就是说每个请求都是独立的
			,所以才有了cookie和session
	无连接 : 限制每次连接只处理一个请求,服务器处理完客户的请求,就会立即断开连接
	HTTP允许传输任意类型的数据对象,正在传输的类型有Content-Type标记
	
	请求头 : Accept-Encoding:允许的编码形式,Accept-Language:支持的语言,
			Cookie:存储在浏览器上的信息,referer:用来让服务器判断来源页面
			User-Agent:浏览器的版本

	响应头 : Content-type:网页内容格式,Connection::连接方式
.从浏览器输入一个网址都发生了什么
	假如是百度, 首先是在host文件中查找有没有对应这个百度域名的网址, 没有的话会访问
	DNS服务器, DNS服务器解析域名得到一个IP, 并且将IP返回给客户端, 然后客户端就会跟这个
	IP对应的服务器建立Tcp链接, 首先客户端向服务端发送syn包, 服务器收到后发送一个syn和
	ack包, 然后客户端再发送服务端一个ack包, Tcp链接成功, 链接成功后客户端向服务端发送
	request请求, 然后服务器解析这个请求, 首先从缓存中找看是不是已经缓存下来的网页,
	然后还要其他啥数据从数据库中拿, 然后返回一个response给浏览器, 浏览器渲染网页

.http和https的区别
	http传输数据是没有经过任何加密的
	,而Https是在http的基础上面加了个SSL协议, 就是一证书, 
	, 这个协议就是用来做身份认证, 加密传输的
	,所以说https比http安全很多, 

.TCP/IP分别在模型的哪一层
	IP在网络层,TCP在运输层

.TCP和UDP的区别
	TCP,面向连接的协议, UDP面向非连接协议
	TCP在链接中有一个三次握手的过程,比较复杂,而UDP它不管你能不能接收到数据
	,就像一个广播一样发给你,所以说速度要比TCP快,但是安全性没有TCP好


.TCP/IP的三次握手
	客户端跟服务端之间发送三个包,三个包发送成功后,两者都进入已连接状态

.HTTP请求和响应的报文三部分
	请求 : 请求行,请求头部,空行,请求数据

	响应 : 响应行,响应头,响应体

.发送post请求的三种方式
	表单,Ajax,.

.HTTP状态码
	1开头 : 服务器收到请求
	2开头 : 成功
	3开头 : 重定向
	4开头 : 客户端错误
	5开头 : 服务器内部错误

.session和cookie的区别
	session存储在服务器,cookie存储在浏览器
	session是一个抽象概念,将浏览器和server之间交互抽象为会话
	而cookie是实际存在的
	一般session都是要借助cookie实现的, 因为一般回话实现都是在cookie中记录会话的ID,
	当然还有其他方法, 例如URL重写(在url中传递会话的ID)

.. 两者的应用	
	cookie不是很安全,如果考虑安全的话可以使用session,
	所以一般将登陆信息或者其他客户比较重要的信息保存到session
	,其他信息可以存到cookie

.session的原理
	为了记录session,在客户端和服务器都要保存数据,
	客户端记录sessionid,在服务器端记录的是一个key-value形式的数据
	访问session的时候,根据cookie上的session_id来访问对应的session数据
	也可以在url中传递session_id

.解决会话跟踪的方法
	URL重写, cookie, 隐藏表单域, 

.get和post请求的差别
	直观一点说,get用来获取数据,post用来提交数据
	相比较而言,get的安全性较差
	get使用url传参数,post使用请求体传参数

.在网页中提供两个链接,一个是在网页中查看文本的内容,另一个是把该文本下载保存到本地
	...

.浏览器的同源策略
	所谓同源是指, 域名，协议，端口相同, 它是浏览器最基本也最核心的安全功能

.列举几个设计用户登陆系统需要考虑到的安全性方面的要点
	可以在登陆页面加个图形验证码或者是手机验证码,不要用明文存储用户的信息
	阻止用户设置一些比较容易被破解的密码

.如何安全存储密码
	使用加密模板,加盐,就是把明文密码和一个随机的字符串拼接在一起

.django中的安全机制
	...

.django的缓存机制
	一般是两种选择,使用memcached或者是数据库,这两个都需要在settings文件中配置CACHES属性
	当然还有文件系统和本地内存缓存,还有独立试图缓存,就是在对应试图函数上面加个装饰器,
	装饰器里设置缓存时间,还有两个参数一个是你指定settings中的那个缓存后端,一个是前缀
	浏览器第一次请求时候,django会缓存单个变量或者是整个网页,

.memcache
	...

.django中的MVC
	MVC,就是将一个项目的逻辑,数据,显示分离开来
	django是一种遵循MVC开发的框架
	M是模型,V是view视图,C是控制器,
	django的MVT本质是和MVC是一样的,M负责和数据库的关系映射ORM
	T代表模板,负责展示页面,V代表试图,负责业务逻辑,

.django实现restful接口
	...

.对tornado异步非阻塞IO的理解
	...

爬虫相关

.爬虫使用过哪些中间件
	UA中间件(UserAgentMiddleware),应对反爬虫用的, 每次发请求时都会随机更换一个UA

数据库相关
.数据库事务的特性
	原子性 : 对数据的操作要不全部执行,要不不执行
	一致性 : 一个事务执行之前后之后数据库都必须处于一致性状态
	分离性 : 并发的事务是相互隔离的,就是一个事务内部的操作的数据必须封锁起来,不被其他企图进行修改的事务看到
	持久性 : 系统发生故障时,确保已提交事务的更新不能丢失,就是一旦一个事务提交
				数据库中的数据改变是永久的

.数据库实现读写分离
	让主数据库处理事务性查询,从数据库处理select查询

.mysql和mongodb的区别
	mongdb是将数据存储为一个文档,基于分布式文件存储的非关系型数据库
	mongodb是以文档形式存储的
	mysql是关系型数据库,以库,表的形式存储
.mysql的三种引擎和主要特点
	myisam
		不支持事务, 也不支持外键, 优势是访问速度快
		, 对事务完整性没有要求,以select,insert为主的应用可以用这个引擎
		,支持表级锁但不支持行级锁

	innodb
		支持外键, 支持事务,事务中包括回滚和提交功能,支持建索引
		, 表和行级锁, 但行级锁需要索引来实现
		支持自动增长列,
	memory
		memory类型的表访问非常快, 因为它的数据是放在内存中的,
		默认使用hash索引

.MySQL慢查询
	就是在日志中记录运行比较慢的SQL语句
	, 需要在MySQL的配置文件中加上 : 
		long_query_time = 时间s(超过多久的SQL会被日志记录下来)
		log-slow_queries = 日志写在哪里

.Innodb索引,联合索引,卡丁值(是什么?)
	...

.数据量太大,并发太高怎么办
	数据量大的话,需要着手数据库了,例如建索引,分库分表
	并发高,可以考虑使用异步IO框架tornado使用memcached缓存用户频繁访问的页面
	,用Nginx负载均衡,html静态化,图片与页面隔离,

.Redis的五种数据类型
	String,List,Set,Sorted Set(有序集合),Hash
	..应用场景
	String : 最常用的数据类型,普通的key/value存储都可以使用此类
	List : 消息队列,可以利用List的PUSH操作,将任务存到list中
	Set : 当你需要存储一个列表数据,又不希望出现重复数据时,
			set还提供了求交集,并集,差集的操作
	Sorted Set : 和set类似,区别就是set不是自动有序的,
					而sorted set可以用过额外提供一个优先级的参数来排序,
					并且插入是有序的,即自动排序
	Hash : 一般是存储用户信息时候用的

.Redis支持事务吗
	支持
	非原子性,不支持回滚

.说一下MySQL事务,回滚
	开始事务一系列操作 : start trasaction
	回滚 : callback
	提交事务操作 : commit
	事务 : 是一个操作序列,这些操作要么都执行,要么都不执行,
			举个例来说, 假如我来给你打100快钱, 假如这个过程是一个事务操作, 也就是两个操作
			一个操作就是从我这减掉100快, 在你那加100快
			, 当在事务操作过程中执行第一个操作(实际上还没有执行)
			但在第二个操作也就是给你加100快这个过程中出了问题, 那就可以使用回滚callback
			这样我的钱就不会减, 你那也不会加

	主要是保持对于数据操作的一致性,
	而回滚就是 : 当事务的某个操作点发生故障,所有更新都可回滚到事务开始之前


GIT操作
.你常用的代码版本管理工具,写出使用该工具更新代码到指定版本的命令行
	git init 创建本地仓库
	git add . 将当前目录所有文件添加到缓存区
	git commit -m 'first commit' 将缓存区的代码
	git remote add origin 远程库地址  将本地库和远程库关联
	git push -u origin master 推送到远程仓库master分支

.git commit --amend有何用处
	对上一次的提交进行修改

.怎么查看某次提交修改的内容
	git log
	git show 'commit-hash'

.如何把分支A上某个commit应用到分支B上
	git cherry-pick commit_id


ftp
ftp进行文件传输时的两种登陆方式, 它们的区别是什么, 常用的ftp文件传输命令是什么
	匿名登陆和授权登陆